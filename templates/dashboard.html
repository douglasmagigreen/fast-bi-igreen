{# templates/dashboard.html - Final com ordenação na tabela fornecedora #}
{% extends "base.html" %}

{# Define o título que pode aparecer na barra superior interna #}
{% block page_title %}Painel de Controle{% endblock %}

{% block content %}

{# Linha para Filtros #}
<div class="filter-row">
    <div class="filter-group">
        <label for="filter-month">FILTRAR POR</label>
        <select id="filter-month" name="month">
            {# Popula as opções passadas pelo Flask #}
            {% for option in month_options %}
                <option value="{{ option.value }}" {% if option.value == selected_month %}selected{% endif %}>
                    {{ option.text }}
                </option>
            {% endfor %}
            {# Fallback se nenhuma opção for passada #}
            {% if not month_options %}
                 <option value="{{ selected_month }}" selected>{{ selected_month }}</option>
            {% endif %}
        </select>
    </div>
</div>

{# Grid para os Widgets/Cards #}
<div class="dashboard-grid">

    {# Card: Resultado do Mês - DINÂMICO #}
    <div class="card kpi-card">
        <div class="card-header">
            Resultado do Mês
            <i class="fas fa-info-circle tooltip-icon" title="Soma do consumo médio dos clientes com data_ativo no mês selecionado."></i>
        </div>
        <div class="card-body">
            <div class="kpi-main-value" id="kpi-total-kwh">
                 {# Formatação inicial do número vindo do Flask #}
                 {{ "{:,.0f}".format(total_kwh).replace(",", "X").replace(".", ",").replace("X", ".") }}
            </div>
            <div class="kpi-sub-label">kWh vendidos</div>
        </div>
    </div>

    {# Card: Clientes do Mês - COM DOIS VALORES E ORDEM INVERTIDA #}
    <div class="card qualification-card">
        <div class="card-header">Clientes do Mês</div>
        <div class="card-body">
            <div class="qualification-numbers" style="display: flex; justify-content: space-around; align-items: flex-start; gap: 15px;">

                {# Contagem por DTCAD (Agora na Esquerda) #}
                <div class="qual-item" style="text-align: center;">
                    <span class="qual-number" id="kpi-clientes-registrados-count" style="font-size: 2.2em;">
                        {{ "{:,.0f}".format(clientes_registrados_count).replace(",", ".") }}
                    </span>
                    <span class="qual-label" style="font-size: 0.85em;">Registrados<br>no mês</span>
                </div>

                {# Contagem por DATA_ATIVO (Agora na Direita) #}
                <div class="qual-item" style="text-align: center;">
                    <span class="qual-number" id="kpi-clientes-ativos-count" style="font-size: 2.2em;">
                        {{ "{:,.0f}".format(clientes_ativos_count).replace(",", ".") }}
                    </span>
                    <span class="qual-label" style="font-size: 0.85em;">Ativados<br>no mês</span>
                </div>

            </div> {# Fim qualification-numbers #}
        </div>
    </div>

    {# Card: Evolução Mensal - GRÁFICO DINÂMICO #}
    <div class="card chart-card">
        <div class="card-header">
            <select id="chart-year" name="year">
                 <option value="2025" selected>2025</option>
                 <option value="2024">2024</option>
                 <option value="2023">2023</option>
            </select>
            <span>Evolução Ativações</span> {# Título ajustado #}
        </div>
        <div class="card-body">
            <canvas id="remunerationChart"></canvas> {# ID mantido, mas representa ativações #}
        </div>
    </div>

    {# Card Resumo por Fornecedora - COM TABELA ORDENÁVEL #}
    <div class="card fornecedora-summary-card grid-span-2">
        <div class="card-header">
            Resumo por Fornecedora (Clientes Ativos)
            <i class="fas fa-info-circle tooltip-icon" title="Contagem e consumo dos clientes com data_ativo no mês selecionado. Clique nos cabeçalhos para ordenar."></i> {# Tooltip atualizado #}
        </div>
        <div class="card-body">
            {# Placeholder para Loading/Erro #}
            <div id="fornecedora-summary-status" style="text-align: center; padding: 20px; display: none;">
                <i class="fas fa-spinner fa-spin"></i> Carregando...
            </div>
            {# Tabela com ID e cabeçalhos modificados #}
            <div class="table-responsive" style="max-height: 250px; overflow-y: auto;">
                <table id="fornecedora-summary-table" class="table table-sm table-striped table-hover"> {# ID adicionado #}
                    <thead>
                        <tr>
                             {# Cabeçalhos com atributos data-* e span para ícone #}
                            <th scope="col" class="sortable-header" data-column-index="0" data-sort-type="text" style="cursor: pointer;">
                                Fornecedora <span class="sort-icon"></span>
                            </th>
                            <th scope="col" class="sortable-header" data-column-index="1" data-sort-type="number" style="text-align: right; cursor: pointer;">
                                Clientes Ativos <span class="sort-icon"></span>
                            </th>
                            <th scope="col" class="sortable-header" data-column-index="2" data-sort-type="number" style="text-align: right; cursor: pointer;">
                                Total de kWh <span class="sort-icon"></span>
                            </th>
                        </tr>
                    </thead>
                    {# O tbody continua sendo preenchido pelo AJAX #}
                    <tbody id="fornecedora-summary-tbody">
                        {# Dados iniciais (se houver) do Flask #}
                         {% if fornecedora_summary %}
                            {% for row in fornecedora_summary %}
                            <tr>
                                <td>{{ row[0] }}</td>
                                <td style="text-align: right;">{{ row[1] | int }}</td>
                                <td style="text-align: right;">{{ "{:,.2f}".format(row[2]).replace(",", "X").replace(".", ",").replace("X", ".") }} kWh</td>
                            </tr>
                            {% endfor %}
                        {% elif not error_summary %}
                            <tr><td colspan="3" style="text-align: center;">Nenhum dado encontrado para o mês selecionado.</td></tr>
                        {% endif %}
                    </tbody>
                </table>
            </div>
            {# Exibe erro inicial do Flask aqui se houver #}
            {% if error_summary %}
                 <p class="text-danger" style="text-align: center; margin-top: 10px;">{{ error_summary }}</p>
            {% endif %}
        </div>
    </div>

</div> {# Fim dashboard-grid #}

{% endblock %}

{# Bloco de Scripts com a lógica AJAX e a NOVA lógica de ordenação #}
{% block scripts_extra %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {

    // --- Variável para guardar a instância do gráfico ---
    let monthlyChartInstance = null;

    // --- Elementos do DOM ---
    const monthSelect = document.getElementById('filter-month');
    const summaryTableBody = document.getElementById('fornecedora-summary-tbody'); // tbody da tabela fornecedora
    const summaryStatus = document.getElementById('fornecedora-summary-status');
    const kpiTotalKwhElement = document.getElementById('kpi-total-kwh');
    const kpiClientesAtivosElement = document.getElementById('kpi-clientes-ativos-count');
    const kpiClientesRegistradosElement = document.getElementById('kpi-clientes-registrados-count');
    const chartCanvas = document.getElementById('remunerationChart');
    const yearSelectChart = document.getElementById('chart-year');

    // --- Função para formatar número ---
    function formatNumber(num, decimalPlaces = 0) {
        if (typeof num !== 'number' || isNaN(num)) return '0';
        return num.toLocaleString('pt-BR', {
            minimumFractionDigits: decimalPlaces,
            maximumFractionDigits: decimalPlaces
        });
    }

    // --- Função para Atualizar Gráfico Mensal ---
    async function updateChartData(year) {
        if (!monthlyChartInstance) { console.error("Instância do Chart não encontrada."); return; }
        // console.log(`Atualizando gráfico para o ano: ${year}`);
        try {
            const apiUrl = "{{ url_for('api_chart_monthly_active_clients') }}";
            const response = await fetch(`${apiUrl}?year=${year}`);
            if (!response.ok) { let errorMsg = `Erro ${response.status}`; try { const d = await response.json(); errorMsg = d.error || errorMsg; } catch(e){} throw new Error(errorMsg); }
            const chartData = await response.json();
            if (chartData && chartData.monthly_counts) {
                monthlyChartInstance.data.datasets[0].data = chartData.monthly_counts;
                monthlyChartInstance.data.datasets[0].label = 'Clientes Ativados';
                monthlyChartInstance.update();
                // console.log("Dados do gráfico atualizados:", chartData.monthly_counts);
            } else {
                 console.warn("Nenhum dado recebido para o gráfico do ano:", year);
                 monthlyChartInstance.data.datasets[0].data = Array(12).fill(0); monthlyChartInstance.data.datasets[0].label = 'Sem dados'; monthlyChartInstance.update();
            }
        } catch (error) { console.error(`Erro ao buscar dados do gráfico para ${year}:`, error); }
    }

    // --- Inicialização do Gráfico ---
    if (chartCanvas && yearSelectChart) {
        const initialYear = yearSelectChart.value;
        const labels = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ'];
        const initialData = { labels: labels, datasets: [{ label: 'Carregando...', data: Array(12).fill(0), fill: false, borderColor: 'rgb(75, 192, 192)', tension: 0.4 }] };
        const config = { type: 'line', data: initialData, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true }, x: { grid: { display: false } } } } };
        monthlyChartInstance = new Chart(chartCanvas, config);
        // console.log("Gráfico inicializado.");
        updateChartData(initialYear); // Busca dados iniciais
        yearSelectChart.addEventListener('change', function() { updateChartData(this.value); });
    } else { if(!chartCanvas) console.error("Elemento canvas do gráfico não encontrado."); if(!yearSelectChart) console.error("Elemento select #chart-year não encontrado."); }

    // --- Função GERAL para buscar dados dos KPIs e Resumo ---
    async function updateDashboardData(month) {
        // Indicadores de carregamento
        if(summaryStatus) { summaryStatus.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Carregando resumo...'; summaryStatus.style.display = 'block'; }
        if(summaryTableBody) summaryTableBody.innerHTML = ''; // Limpa antes de preencher
        if(kpiTotalKwhElement) kpiTotalKwhElement.innerHTML = '<i class="fas fa-spinner fa-spin fa-xs"></i>';
        if(kpiClientesAtivosElement) kpiClientesAtivosElement.innerHTML = '<i class="fas fa-spinner fa-spin fa-xs"></i>';
        if(kpiClientesRegistradosElement) kpiClientesRegistradosElement.innerHTML = '<i class="fas fa-spinner fa-spin fa-xs"></i>';

        const fetchSummary = fetch("{{ url_for('api_fornecedora_summary') }}?month=" + month);
        const fetchKpiKwh = fetch("{{ url_for('api_kpi_total_kwh') }}?month=" + month);
        const fetchKpiClientes = fetch("{{ url_for('api_kpi_clientes_ativos') }}?month=" + month);
        const fetchKpiRegistrados = fetch("{{ url_for('api_kpi_clientes_registrados') }}?month=" + month);

        try {
            const [summaryResponse, kpiKwhResponse, kpiClientesResponse, kpiRegistradosResponse] = await Promise.all([
                fetchSummary, fetchKpiKwh, fetchKpiClientes, fetchKpiRegistrados
            ]);

            // Processa Resumo Fornecedora - PREENCHE A TABELA
            if (summaryTableBody && summaryStatus) {
                 if (!summaryResponse.ok) { let errorMsg = `Erro ${summaryResponse.status}`; try { const d = await summaryResponse.json(); errorMsg = d.error || errorMsg; } catch(e){} throw new Error(`Falha ao buscar resumo: ${errorMsg}`); }
                 const dataSummary = await summaryResponse.json();
                 summaryStatus.style.display = 'none'; // Esconde o loading
                 summaryTableBody.innerHTML = ''; // Garante que está limpo antes de adicionar
                 if (dataSummary && dataSummary.length > 0) {
                    dataSummary.forEach(row => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td>${row.fornecedora}</td>
                                        <td style="text-align: right;">${formatNumber(row.qtd_clientes, 0)}</td>
                                        <td style="text-align: right;">${formatNumber(row.soma_consumo, 2)} kWh</td>`;
                        summaryTableBody.appendChild(tr);
                     });
                     // Após preencher, talvez chamar uma função para re-aplicar a ordenação atual? Ou deixar o usuário clicar.
                 } else {
                     summaryTableBody.innerHTML = '<tr><td colspan="3" style="text-align: center;">Nenhum dado encontrado para este mês.</td></tr>';
                 }
            }

            // Processa KPI Total kWh
            if (kpiTotalKwhElement) {
                if (!kpiKwhResponse.ok) { let errorMsg = `Erro ${kpiKwhResponse.status}`; try { const d = await kpiKwhResponse.json(); errorMsg = d.error || errorMsg; } catch(e){} throw new Error(`Falha ao buscar Total kWh: ${errorMsg}`); }
                const dataKpi = await kpiKwhResponse.json();
                kpiTotalKwhElement.textContent = formatNumber(dataKpi.total_kwh, 0);
            }

             // Processa KPI Clientes Ativos (data_ativo)
             if (kpiClientesAtivosElement) {
                 if (!kpiClientesResponse.ok) { let errorMsg = `Erro ${kpiClientesResponse.status}`; try { const d = await kpiClientesResponse.json(); errorMsg = d.error || errorMsg; } catch(e){} throw new Error(`Falha ao buscar clientes ativos: ${errorMsg}`); }
                 const dataClientes = await kpiClientesResponse.json();
                 kpiClientesAtivosElement.textContent = formatNumber(dataClientes.clientes_ativos_count, 0);
             }

             // Processa KPI Clientes Registrados (dtcad)
             if (kpiClientesRegistradosElement) {
                 if (!kpiRegistradosResponse.ok) { let errorMsg = `Erro ${kpiRegistradosResponse.status}`; try { const d = await kpiRegistradosResponse.json(); errorMsg = d.error || errorMsg; } catch(e){} throw new Error(`Falha ao buscar clientes registrados: ${errorMsg}`); }
                 const dataRegistrados = await kpiRegistradosResponse.json();
                 kpiClientesRegistradosElement.textContent = formatNumber(dataRegistrados.clientes_registrados_count, 0);
             }

        } catch (error) {
            console.error('Erro ao buscar dados do dashboard:', error);
            if(summaryStatus) { summaryStatus.innerHTML = `<span style="color: red;"><i class="fas fa-exclamation-triangle"></i> Erro: ${error.message}</span>`; summaryStatus.style.display = 'block'; }
            if(kpiTotalKwhElement) kpiTotalKwhElement.innerHTML = `<span style="font-size: 0.5em; color: red;">Erro!</span>`;
            if(kpiClientesAtivosElement) kpiClientesAtivosElement.innerHTML = `<span style="font-size: 0.5em; color: red;">Erro!</span>`;
            if(kpiClientesRegistradosElement) kpiClientesRegistradosElement.innerHTML = `<span style="font-size: 0.5em; color: red;">Erro!</span>`;
        }
    }

    // --- Listener para o filtro de MÊS ---
    if (monthSelect) {
        monthSelect.addEventListener('change', function() {
            const selectedMonth = this.value;
            const currentUrl = new URL(window.location);
            currentUrl.searchParams.set('month', selectedMonth);
            window.history.replaceState({}, '', currentUrl);
            updateDashboardData(selectedMonth); // Chama a função geral para buscar TODOS os dados
        });
        // Chama para carregar dados iniciais via AJAX
        updateDashboardData(monthSelect.value);
    } else {
        console.error("Elemento #filter-month não encontrado.");
    }

    // --- NOVO: LÓGICA PARA ORDENAÇÃO DA TABELA FORNECEDORA ---
    // Seleciona a tabela após o DOM estar pronto
    const fornecedoraTable = document.getElementById('fornecedora-summary-table');
    const fornecedoraTableBody = document.getElementById('fornecedora-summary-tbody');
    const fornecedoraHeaders = fornecedoraTable ? fornecedoraTable.querySelectorAll('thead th.sortable-header') : [];

    let currentSortColumnIndex = -1; // Nenhuma coluna ordenada inicialmente
    let currentSortDirection = 'none'; // 'asc', 'desc', 'none'

    // Função auxiliar para obter o valor da célula para comparação
    function getCellValue(row, columnIndex, sortType) {
        const cell = row.cells[columnIndex];
        let value = cell ? cell.textContent || cell.innerText : '';

        if (sortType === 'number') {
            // Limpa valor (remove pontos de milhar, ' kWh', espaços; troca vírgula decimal por ponto)
            value = value.replace(/\./g, '').replace(/ kWh/gi, '').replace(',', '.').trim();
            // Tenta converter para float, retorna 0 em caso de falha ou NaN
            const num = parseFloat(value);
            return isNaN(num) ? 0 : num;
        }
        // Para texto, retorna em minúsculas para ordenação case-insensitive
        return value.trim().toLowerCase();
    }

    // Função para atualizar ícones dos cabeçalhos (setas ▲/▼)
    function updateSortIcons(clickedHeader) {
        fornecedoraHeaders.forEach(header => {
            const iconSpan = header.querySelector('.sort-icon');
            if (iconSpan) {
                // Se for o cabeçalho clicado, define a seta apropriada
                if (header === clickedHeader) {
                    iconSpan.textContent = currentSortDirection === 'asc' ? ' ▲' : (currentSortDirection === 'desc' ? ' ▼' : '');
                } else {
                    // Limpa ícones de outros cabeçalhos
                    iconSpan.textContent = '';
                }
            }
        });
    }

    // Adiciona listener de clique para cada cabeçalho ordenável
    fornecedoraHeaders.forEach(header => {
        header.addEventListener('click', function() {
            const columnIndex = parseInt(this.getAttribute('data-column-index'), 10);
            const sortType = this.getAttribute('data-sort-type');

            // Se clicou na mesma coluna, inverte direção; senão, ordena ASC
            if (columnIndex === currentSortColumnIndex) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumnIndex = columnIndex;
                currentSortDirection = 'asc'; // Direção padrão ao clicar numa nova coluna
            }

            // Atualiza os ícones de seta nos cabeçalhos
            updateSortIcons(this);

            // Pega as linhas TR atuais do tbody e converte para um Array
            const rows = Array.from(fornecedoraTableBody.querySelectorAll('tr'));

            // Ordena o array de linhas TR
            rows.sort((rowA, rowB) => {
                const valueA = getCellValue(rowA, currentSortColumnIndex, sortType);
                const valueB = getCellValue(rowB, currentSortColumnIndex, sortType);
                let comparison = 0;

                // Compara baseado no tipo (número ou texto)
                if (sortType === 'number') {
                    comparison = valueA - valueB; // Ordenação numérica
                } else { // sortType === 'text'
                    comparison = valueA.localeCompare(valueB, 'pt-BR'); // Ordenação alfabética PT-BR
                }

                // Aplica a direção (ascendente ou descendente)
                return currentSortDirection === 'asc' ? comparison : comparison * -1;
            });

            // Limpa o corpo da tabela (remove todas as linhas existentes)
            fornecedoraTableBody.innerHTML = '';

            // Reanexa as linhas (TRs) ordenadas de volta ao corpo da tabela
            rows.forEach(row => fornecedoraTableBody.appendChild(row));
        });
    });
    // --- FIM LÓGICA ORDENAÇÃO ---

}); // Fim DOMContentLoaded
</script>
{% endblock %}